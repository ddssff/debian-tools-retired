{-# LANGUAGE ScopedTypeVariables #-}
module Debian.Repo.SourceTree 
    ( -- * Source Tree
      SourceTreeC(..)
    , DebianSourceTreeC(..)
    , DebianBuildTreeC(..)
    , SourceTree(..)
    , DebianSourceTree(..)
    , DebianBuildTree(..)
    , findChanges
    , SourcePackageStatus(..)
    , buildDebs
    , findSourceTree
    , copySourceTree
    , findDebianSourceTree
    , copyDebianSourceTree
    , findDebianSourceTrees
    , findDebianBuildTree
    , findDebianBuildTrees
    , copyDebianBuildTree
    , findOneDebianBuildTree
    , explainSourcePackageStatus
    , addLogEntry
    , findOrigTarball
    , origTarballPath
    ) where

import Control.Exception (SomeException, try, evaluate)
import Control.Monad (foldM)
import Control.Monad.Trans ( MonadIO(..) )
import qualified Data.ByteString.Lazy.Char8 as L ( empty )
import Data.List ( nubBy, sortBy, intercalate )
import Data.Maybe ( fromJust )
import Data.Time ( NominalDiffTime )
import Debian.Changes ( ChangeLogEntry(..), parseLog, ChangesFile(..), prettyChangesFile, prettyEntry )
import Debian.Control.String ( Field'(Comment), Paragraph'(..), Control'(Control), ControlFunctions(parseControl), Control )
import Debian.Relation (BinPkgName)
import Debian.Repo.Changes ( findChangesFiles )
import Debian.Repo.OSImage ( OSImage )
import Debian.Repo.Types ( AptCache(rootDir), EnvRoot(rootPath) )
import qualified Debian.Version as V ( version )
import Extra.Files ( replaceFile, getSubDirectories )
import Extra.List ( dropPrefix )
import System.Directory ( createDirectoryIfMissing, doesDirectoryExist, doesFileExist )
import System.Environment ( getEnv )
import System.Exit (ExitCode(ExitFailure))
import System.IO (withFile, IOMode(ReadMode), hGetContents)
import System.Process (CmdSpec(..))
import System.Process.Progress (runProcess, runProcessF, timeTask, quieter, keepResult)
import System.Unix.Chroot ( useEnv )

-- |Any directory containing source code.
class SourceTreeC t where
    topdir :: t -> FilePath		-- ^The top directory of the source tree

-- |A Debian source tree, which has a debian subdirectory containing
-- at least a control file and a changelog.
class SourceTreeC t => DebianSourceTreeC t where
    debdir :: t -> FilePath		-- ^The directory containing the debian subdirectory
    control :: t -> Control		-- ^The contents of debian\/control
    entry :: t -> ChangeLogEntry	-- ^The latest entry from debian\/changelog

-- |A debian source tree plus a parent directory, which is where the
-- binary and source deb packages appear after a build.
class DebianSourceTreeC t => DebianBuildTreeC t where
    subdir :: t -> String		-- ^The basename of debdir

-- |Any directory containing source code.
data SourceTree =
    SourceTree {dir' :: FilePath} deriving Show

-- |A Debian source tree, which has a debian subdirectory containing
-- at least a control file and a changelog.
data DebianSourceTree =
    DebianSourceTree {tree' :: SourceTree,
                      control' :: Control,
                      entry' :: ChangeLogEntry}

-- |A Debian source tree plus a parent directory, which is where the
-- binary and source deb packages appear after a build.
data DebianBuildTree =
    DebianBuildTree {topdir' :: FilePath,
                     subdir' :: String,
                     debTree' :: DebianSourceTree}

instance SourceTreeC SourceTree where
    topdir = dir'

instance SourceTreeC DebianSourceTree where
    topdir = dir' . tree'

instance DebianSourceTreeC DebianSourceTree where
    debdir = dir' . tree'
    control = control'
    entry = entry'

instance SourceTreeC DebianBuildTree where
    topdir = topdir'

instance DebianSourceTreeC DebianBuildTree where
    debdir t = topdir' t ++ "/" ++ subdir' t
    control = control' . debTree'
    entry = entry' . debTree'

instance DebianBuildTreeC DebianBuildTree where
    subdir = subdir'

-- |Find the .changes file which is generated by a successful run of
-- dpkg-buildpackage.
findChanges :: DebianBuildTree -> IO ChangesFile
findChanges tree =
    do let dir = topdir tree
       result <- findChangesFiles dir
       case result of
         [cf] -> return cf
         [] -> fail ("Couldn't find .changes file in " ++ dir)
         lst -> fail ("Multiple .changes files in " ++ dir ++ ": " ++ intercalate ", " (map (show . prettyChangesFile) lst))

-- |Rewrite the changelog with an added entry.
addLogEntry :: DebianSourceTreeC t => ChangeLogEntry -> t -> IO ()
addLogEntry entry debtree =
-- readFile changelogPath >>= replaceFile changelogPath . ((show (prettyEntry entry)) ++)
  withFile changelogPath ReadMode (\ handle -> hGetContents handle >>= replaceFile changelogPath . ((show (prettyEntry entry)) ++))
    where
      changelogPath = (debdir debtree) ++ "/debian/changelog"

-- |There are three possible results of a build: an upload consisting
-- of only the architecture independent debs (Indep), one including
-- both indep and binary debs (All), or with a failed build (None).
data SourcePackageStatus = All | Indep [BinPkgName] | None deriving (Show, Eq)

explainSourcePackageStatus :: SourcePackageStatus -> String
explainSourcePackageStatus All = "All architecture dependent files for the current build architecture are present."
explainSourcePackageStatus (Indep missing) = "Some or all architecture-dependent files for the current build architecture are missing: " ++ show missing
explainSourcePackageStatus None = "This version of the package is not present."

-- | Run dpkg-buildpackage in a source tree.
buildDebs :: (DebianBuildTreeC t) => Bool -> Bool -> [String] -> OSImage -> t -> SourcePackageStatus -> IO NominalDiffTime
buildDebs noClean twice setEnv buildOS buildTree status =
    do
      noSecretKey <- getEnv "HOME" >>= return . (++ "/.gnupg") >>= doesDirectoryExist >>= return . not
      -- Set LOGNAME so dpkg-buildpackage doesn't die when it fails to
      -- get the original user's login information
      let buildcmd =
              "dpkg-buildpackage -sa "
              ++ (case status of Indep _ -> " -B "; _ -> "")
                     ++ (if noSecretKey then " -us -uc" else "")
                            ++ (if noClean then " -nc" else "")
      let fullcmd = ("export LOGNAME=root; " ++
                     concat (map (\ x -> "export " ++ x ++ "; ") setEnv) ++
                     "cd '" ++ fromJust (dropPrefix root path) ++ "' && " ++
                     "chmod ugo+x debian/rules && " ++
                     if  twice
                     -- Try to build twice, some packages do configuration the first
                     -- time 'so that it is NEVER run during an automated build.' :-/
                     then "{ " ++ buildcmd ++ " || " ++ buildcmd ++ " ; } "
                     else buildcmd)
      (result, elapsed) <- timeTask . useEnv root forceList $ quieter (-3) $ runProcessF id (ShellCommand fullcmd) L.empty
      case keepResult result of
        (ExitFailure n : _) -> fail $ "*** FAILURE: " ++ fullcmd ++ " -> " ++ show n
        _ -> return elapsed
    where
      path = debdir buildTree
      root = rootPath (rootDir buildOS)

forceList :: [a] -> IO [a]
forceList output = evaluate (length output) >> return output

-- |Make a copy of a source tree in a directory.
copySourceTree :: (SourceTreeC t) => t -> FilePath -> IO SourceTree
copySourceTree tree dest =
    createDirectoryIfMissing True dest >> runProcessF id (ShellCommand command) L.empty >> return (SourceTree dest)
    where
      command = "rsync -aHxSpDt --delete '" ++ topdir tree ++ "/' '" ++ dest ++ "'"



copyDebianSourceTree :: (DebianSourceTreeC t) => t -> FilePath -> IO DebianSourceTree
copyDebianSourceTree src dest =
    copySourceTree src dest >>= \ copy -> return (DebianSourceTree copy (control src) (entry src))

copyDebianBuildTree :: (DebianBuildTreeC t) => t -> FilePath -> IO DebianBuildTree
copyDebianBuildTree src dest =
    copySource >>= copyTarball >>= makeTree
    where
      copySource = copySourceTree (SourceTree . topdir $ src) dest
      copyTarball copy =
          do exists <- liftIO $ doesFileExist origPath
             case exists of
               False -> return copy
               True -> runProcess id (ShellCommand cmd) L.empty >> return copy
      makeTree copy =
          return $ (DebianBuildTree (dir' copy) (subdir src)
                    (DebianSourceTree { tree' = SourceTree { dir' = dest ++ "/" ++ subdir src }
                                      , control' = (control src)
                                      , entry' = (entry src) }))
{-
    do copy <- copySourceTree (SourceTree . topdir $ src) dest
       exists <- io $ doesFileExist origPath
       --io $ System.IO.hPutStrLn stderr ("doesFileExist " ++ show origPath ++ " -> " ++ show exists)
       case exists of
         True -> quietRunOutputOnError cmd
         False -> return ([], noTimeDiff)
       return $ DebianBuildTree (dir' copy) (subdir src)
                  (DebianSourceTree { tree' = SourceTree { dir' = dest { envPath = envPath dest ++ "/" ++ subdir src } }
                                    , control' = (control src)
                                    , entry' = (entry src) })
    where
-}
      cmd = ("cp -p " ++ origPath ++ " " ++ dest ++ "/")
      origPath = topdir src ++ "/" ++ orig
      orig = name ++ "_" ++ version ++ ".orig.tar.gz"
      name = logPackage . entry $ src
      version = V.version . logVersion . entry $ src

findSourceTree :: FilePath -> IO SourceTree
findSourceTree path =
    doesDirectoryExist path >>= \ exists ->
    case exists of
      False -> fail $ "No such directory: " ++ path
      True -> return $ SourceTree path

findDebianSourceTree :: FilePath -> IO DebianSourceTree
findDebianSourceTree path0 =
    findSourceTree path0 >>= \ tree ->
    readFile controlPath >>= return . parseControl controlPath >>= either (fail . show) (return . removeCommentParagraphs) >>= \ control ->
    -- We only read part of the changelog, so be careful that the file
    -- descriptor gets closed.
    withFile changelogPath ReadMode
      (\ handle ->
        hGetContents handle >>= \ log ->
        case parseLog log of
          (Right entry : _) ->
            -- ePutStrLn ("findDebianSourceTree " ++ show path0 ++ " -> " ++ topdir tree) >>
            return (DebianSourceTree tree control entry)
          (Left msgs : _) -> error $ "Bad changelog entry in " ++ show changelogPath ++ ": " ++ intercalate ", " msgs
          [] -> return $ error $ "Empty changelog file: " ++ show changelogPath)
    where
      controlPath = path0 ++ "/debian/control"
      changelogPath = path0 ++ "/debian/changelog"
{-
    do --vPutStrLn 2 stderr $ "findDebianSourceTree " ++ show path
       findSourceTree path >>= either (return . Left) findDebianSource
    where
      findDebianSource :: SourceTree -> IO (Either String DebianSourceTree)
      findDebianSource tree@(SourceTree path) =
          do let controlPath = path ++ "/debian/control"
                 changelogPath = path ++ "/debian/changelog"
             control <-
                 liftIO (try . readFile $ controlPath) >>=
                 return . either (\ (e :: SomeException) -> Left . (("Could not read control file: " ++ controlPath ++ ": ") ++) . show $ e)
                            (either (const (Left $ "Parse error in control file: " ++ controlPath)) (Right . removeCommentParagraphs) .
                                        (parseControl controlPath))
             log <- liftIO (try . readFile $ changelogPath) >>= 
                    return . either (\ (e :: SomeException) -> Left . ("Failure reading changelog: " ++) . show $ e) (Right . parseLog)
             case (control, log) of
               (Right control, (Right (Right entry : _))) -> return . Right $ DebianSourceTree tree control entry
               (Right _control, (Right [Left msgs])) -> return . Left $ "Bad changelog entry: " ++ changelogPath ++ " -> " ++ intercalate "\n" msgs
               (Right _control, (Right [])) -> return . Left $ "Empty changelog file: " ++ changelogPath
               (Right _control, (Left msgs)) -> return . Left $ "Bad changelog in " ++ changelogPath ++ ": " ++ msgs
               (Left control, _) -> return . Left $ "Bad control file: " ++ controlPath ++ " -> " ++ show control
               (_, Left log) -> return . Left $ "Bad changelog: " ++ changelogPath ++ " -> " ++ show log
-}

removeCommentParagraphs (Control paragraphs) =
    Control (filter (not . isCommentParagraph) paragraphs)
    where
      isCommentParagraph (Paragraph fields) = all isCommentField fields
      isCommentField (Comment _) = True
      isCommentField _ = False

-- |Find a DebianBuildTree inside a directory.  It finds all the
-- DebianSourceTrees, and if they all have the same package name it
-- returns the newest one according to the version numbers.  If there
-- are none, or there are trees with different package names, Nothing
-- is returned.
findOneDebianBuildTree :: FilePath -> IO (Maybe DebianBuildTree)
findOneDebianBuildTree path =
    do trees <- findDebianBuildTrees path
       -- Do all the trees have the same package name?
       case nubBy eqNames trees of
         -- Yes, return the newest one
         [_] -> return . Just . head . sortBy cmpVers $ trees
         -- No trees found
         [] -> return Nothing
         -- No, throw an exception
         names -> error $ "findOneDebianBuildTree: more than one source package name found in " ++ path ++ ": " ++ show (map (logPackage . entry) names)
    where
      eqNames tree1 tree2 = (logPackage . entry $ tree1) == (logPackage . entry $ tree2)
      cmpVers tree1 tree2 = compare (logVersion . entry $ tree1) (logVersion . entry $ tree2)

-- |Find the DebianBuildTree where the debianized source is in a particular subdirectory.
findDebianBuildTree :: FilePath -> String -> IO DebianBuildTree
findDebianBuildTree path name =
    findDebianSourceTree (path ++ "/" ++ name) >>= return . DebianBuildTree path name
    

-- |Find all the debian source trees in a directory.
findDebianSourceTrees :: FilePath -> IO [(FilePath, DebianSourceTree)]
findDebianSourceTrees path =
    getSubDirectories path >>= \ (subdirs :: [FilePath]) ->
    foldM (\ pairs subdir -> try (findDebianSourceTree (path ++ "/" ++ subdir)) >>=
                             either (\ (_ :: SomeException) -> return pairs) (\ tree -> return ((subdir, tree) : pairs))) [] subdirs

-- |Find all the debian source trees in a directory.
findDebianBuildTrees :: FilePath -> IO [DebianBuildTree]
findDebianBuildTrees path =
    -- ePutStrLn ("findDebianBuildTrees " ++ path) >>
    findDebianSourceTrees path >>=
    return . map (\ (subdir, tree) -> DebianBuildTree { topdir' = path, subdir' = subdir, debTree' = tree })
{-
    getSubDirectories path >>= \ (subdirs :: [FilePath]) ->
    mapM (\ subdir -> try (findDebianSourceTree (path ++ "/" ++ subdir))) subdirs >>= \ (trees :: [Either SomeException DebianSourceTree]) -> 
    return . partitionEithers . map makeResult $ zip subdirs trees
    where
      makeResult (subdir, Left e) = Left (subdir, e)
      makeResult (subdir, Right t) = Right (DebianBuildTree path subdir t)
-}

findOrigTarball :: DebianBuildTree -> IO (Maybe FilePath)
findOrigTarball tree =
    do exists <- doesFileExist (origTarballPath tree)
       return $ if exists then Just (origTarballPath tree) else Nothing

origTarballPath :: DebianBuildTree -> FilePath
origTarballPath tree =
    topdir tree ++ "/" ++ orig
    where
      orig = name ++ "_" ++ version ++ ".orig.tar.gz"
      name = logPackage . entry $ tree
      version = V.version . logVersion . entry $ tree
